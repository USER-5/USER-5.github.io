<h2>Functional Refactoring</h2>
<h3>The Problem</h3>
<p>
Say you have a function that does something:
<code>
	<pre>
function getDisplayProducts(products: Product[], query: string): Product[] {
	const trimmedQuery = query.trim();

	// If any of the string properties match, keep the product
	let filteredProducts = products.map(product =&gt; {
		return product.name.contains(query) || 
			product.description.contains(query) || 
			product.subtitle.contains(query) || 
			product.tags.includes(query) ||
	});

	// Add suggested products to the start of the list
	filteredProducts.prepend(new Product("suggested purchase: apple"));
	filteredProducts.prepend(new Product("suggested purchase: banana"));
	
	filteredProducts = filteredProducts.limit(10)
	
	return filteredProducts;
}
	</pre>
</code>
Fantastic. You're well on your way to a succesful program.
</p>
<p>And, despite what this article is about - this is <em>fine</em>.
If this showed up for me to review, I might comment about extracting the suggested products into a list, but that's about it.
But I'll use it anyway to demonstrate my point. See those blocks with comments above them? They're excellent candidates for my favourite type of refactor: <a href="https://refactoring.guru/extract-method">Extract Function (or method)</a>.
</p>
<h3>The Refactor</h3>
<p>
The refactor is simple - pull those parts out into their own functions. The reasoning is slightly more complex.
<code>
	<pre>
function productMatchesQuery(product: Product, query: string): boolean {
	return product.name.contains(query) || 
		product.description.contains(query) || 
		product.subtitle.contains(query) || 
		product.tags.includes(query) ||
}

function addSuggestedProducts(products: Product[]): Product[] {
	return [
		new Product("suggested purchase: apple"),
		new Product("suggested purchase: banana"),
		...products
	];
}

function getDisplayProducts(products: Product[], query: string): Product[] {
	const trimmedQuery = query.trim();

	let filteredProducts = products.map(product =&gt; productMatchesQuery(product, query));
	
	filteredProducts = addSuggestedProducts(filteredProducts);

	filteredProducts = filteredProducts.limit(10)
	
	return filteredProducts;
}
	</pre>
</code>
Now, is this overkill in this case? Almost certainly. Are there other ways I would refactor this specific code? Yes. But good code examples are hard to come by.
</p>
<h3>The Reasoning</h3>
<p>
	What are the problems that this addresses?
</p>
<h4>Comments Are Technical Debt</h4>
<p>We all like to hate on comments - and most of the time, code could be commented more.
But I believe that comments are technical debt.</p>
<p>They don't actually do anything. They can't be tested. They can fall out of sync with the code.
</p>
<p>And worst of all - if the code they're explaining changes, they don't need to be updated. Now you have code that's explained <em>incorrectly</em>. I can't think of anything more confusing.
</p>
<h4>Functions Can be Reused</h4>
<p>
Extracting behaviour into a function means that the next person who needs to do thing Y can just refer to the existing implementation. There's less chance of a lazy dev copying the behaviour they need.
</p>
<h4>Functions are Basically Labelled Blocks of Code, but Better</h4>
<p>
So we can see the the function name basically provides the information that was in the comments before, but you get the added benefit of knowing exactly what the inputs and outputs of a function is.
A function can't access things outside of its input parameters - so you know that it's not going to modify anything else (and realy it shouldn't modify its inputs either, right?).
</p>

